// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: course_sections.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createCourseSection = `-- name: CreateCourseSection :one
INSERT INTO course_sections (
    course_id,
    name,
    teacher_id,
    max_students
) VALUES (
    $1, $2, $3, $4
) RETURNING id, course_id, teacher_id, max_students, created_at, updated_at, name
`

type CreateCourseSectionParams struct {
	CourseID    uuid.UUID `json:"course_id"`
	Name        string    `json:"name"`
	TeacherID   uuid.UUID `json:"teacher_id"`
	MaxStudents int32     `json:"max_students"`
}

func (q *Queries) CreateCourseSection(ctx context.Context, arg CreateCourseSectionParams) (CourseSection, error) {
	row := q.queryRow(ctx, q.createCourseSectionStmt, createCourseSection,
		arg.CourseID,
		arg.Name,
		arg.TeacherID,
		arg.MaxStudents,
	)
	var i CourseSection
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.TeacherID,
		&i.MaxStudents,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}

const deleteCourseSection = `-- name: DeleteCourseSection :exec
DELETE FROM course_sections
WHERE id = $1
`

func (q *Queries) DeleteCourseSection(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteCourseSectionStmt, deleteCourseSection, id)
	return err
}

const enrollStudent = `-- name: EnrollStudent :one
INSERT INTO section_enrollments (
    section_id,
    student_id
) VALUES (
    $1, $2
) RETURNING id, section_id, student_id, created_at, updated_at
`

type EnrollStudentParams struct {
	SectionID uuid.UUID `json:"section_id"`
	StudentID uuid.UUID `json:"student_id"`
}

func (q *Queries) EnrollStudent(ctx context.Context, arg EnrollStudentParams) (SectionEnrollment, error) {
	row := q.queryRow(ctx, q.enrollStudentStmt, enrollStudent, arg.SectionID, arg.StudentID)
	var i SectionEnrollment
	err := row.Scan(
		&i.ID,
		&i.SectionID,
		&i.StudentID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourseSectionByID = `-- name: GetCourseSectionByID :one
SELECT id, course_id, teacher_id, max_students, created_at, updated_at, name FROM course_sections
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCourseSectionByID(ctx context.Context, id uuid.UUID) (CourseSection, error) {
	row := q.queryRow(ctx, q.getCourseSectionByIDStmt, getCourseSectionByID, id)
	var i CourseSection
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.TeacherID,
		&i.MaxStudents,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}

const getCourseSectionsByCourseID = `-- name: GetCourseSectionsByCourseID :many
SELECT id, course_id, teacher_id, max_students, created_at, updated_at, name FROM course_sections
WHERE course_id = $1
`

func (q *Queries) GetCourseSectionsByCourseID(ctx context.Context, courseID uuid.UUID) ([]CourseSection, error) {
	rows, err := q.query(ctx, q.getCourseSectionsByCourseIDStmt, getCourseSectionsByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CourseSection{}
	for rows.Next() {
		var i CourseSection
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.TeacherID,
			&i.MaxStudents,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseSectionsByStudentID = `-- name: GetCourseSectionsByStudentID :many
SELECT cs.id, cs.course_id, cs.teacher_id, cs.max_students, cs.created_at, cs.updated_at, cs.name FROM course_sections cs
JOIN section_enrollments se ON cs.id = se.section_id
WHERE se.student_id = $1
`

func (q *Queries) GetCourseSectionsByStudentID(ctx context.Context, studentID uuid.UUID) ([]CourseSection, error) {
	rows, err := q.query(ctx, q.getCourseSectionsByStudentIDStmt, getCourseSectionsByStudentID, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CourseSection{}
	for rows.Next() {
		var i CourseSection
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.TeacherID,
			&i.MaxStudents,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseSectionsByTeacherID = `-- name: GetCourseSectionsByTeacherID :many
SELECT id, course_id, teacher_id, max_students, created_at, updated_at, name FROM course_sections
WHERE teacher_id = $1
`

func (q *Queries) GetCourseSectionsByTeacherID(ctx context.Context, teacherID uuid.UUID) ([]CourseSection, error) {
	rows, err := q.query(ctx, q.getCourseSectionsByTeacherIDStmt, getCourseSectionsByTeacherID, teacherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CourseSection{}
	for rows.Next() {
		var i CourseSection
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.TeacherID,
			&i.MaxStudents,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseSectionsWithSchedulesByStudentID = `-- name: GetCourseSectionsWithSchedulesByStudentID :many
SELECT 
    cs.id,
    cs.course_id,
    cs.teacher_id,
    cs.max_students,
    cs.created_at,
    cs.updated_at,
    cs.name,
    s.id as schedule_id,
    s.course_id as schedule_course_id,
    s.section_id as schedule_section_id,
    s.classroom_id,
    s.day_of_week,
    s.start_time,
    s.end_time,
    s.created_at as schedule_created_at,
    s.updated_at as schedule_updated_at
FROM course_sections cs
JOIN section_enrollments se ON cs.id = se.section_id
LEFT JOIN schedules s ON cs.id = s.section_id
WHERE se.student_id = $1
ORDER BY cs.id, s.day_of_week, s.start_time
`

type GetCourseSectionsWithSchedulesByStudentIDRow struct {
	ID                uuid.UUID     `json:"id"`
	CourseID          uuid.UUID     `json:"course_id"`
	TeacherID         uuid.UUID     `json:"teacher_id"`
	MaxStudents       int32         `json:"max_students"`
	CreatedAt         sql.NullTime  `json:"created_at"`
	UpdatedAt         sql.NullTime  `json:"updated_at"`
	Name              string        `json:"name"`
	ScheduleID        uuid.NullUUID `json:"schedule_id"`
	ScheduleCourseID  uuid.NullUUID `json:"schedule_course_id"`
	ScheduleSectionID uuid.NullUUID `json:"schedule_section_id"`
	ClassroomID       uuid.NullUUID `json:"classroom_id"`
	DayOfWeek         sql.NullInt32 `json:"day_of_week"`
	StartTime         sql.NullTime  `json:"start_time"`
	EndTime           sql.NullTime  `json:"end_time"`
	ScheduleCreatedAt sql.NullTime  `json:"schedule_created_at"`
	ScheduleUpdatedAt sql.NullTime  `json:"schedule_updated_at"`
}

func (q *Queries) GetCourseSectionsWithSchedulesByStudentID(ctx context.Context, studentID uuid.UUID) ([]GetCourseSectionsWithSchedulesByStudentIDRow, error) {
	rows, err := q.query(ctx, q.getCourseSectionsWithSchedulesByStudentIDStmt, getCourseSectionsWithSchedulesByStudentID, studentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourseSectionsWithSchedulesByStudentIDRow{}
	for rows.Next() {
		var i GetCourseSectionsWithSchedulesByStudentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.TeacherID,
			&i.MaxStudents,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.ScheduleID,
			&i.ScheduleCourseID,
			&i.ScheduleSectionID,
			&i.ClassroomID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.ScheduleCreatedAt,
			&i.ScheduleUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnrollmentCount = `-- name: GetEnrollmentCount :one
SELECT COUNT(*) FROM section_enrollments
WHERE section_id = $1
`

func (q *Queries) GetEnrollmentCount(ctx context.Context, sectionID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.getEnrollmentCountStmt, getEnrollmentCount, sectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEnrollmentsWithDetailsBySection = `-- name: GetEnrollmentsWithDetailsBySection :many
SELECT 
    se.id,
    se.section_id,
    se.student_id,
    se.created_at,
    se.updated_at,
    u.id as student_id,
    u.email,
    u.first_name,
    u.last_name,
    u.role,
    u.created_at as user_created_at,
    u.updated_at as user_updated_at
FROM section_enrollments se
JOIN users u ON se.student_id = u.id
WHERE se.section_id = $1
ORDER BY se.created_at
`

type GetEnrollmentsWithDetailsBySectionRow struct {
	ID            uuid.UUID    `json:"id"`
	SectionID     uuid.UUID    `json:"section_id"`
	StudentID     uuid.UUID    `json:"student_id"`
	CreatedAt     sql.NullTime `json:"created_at"`
	UpdatedAt     sql.NullTime `json:"updated_at"`
	StudentID_2   uuid.UUID    `json:"student_id_2"`
	Email         string       `json:"email"`
	FirstName     string       `json:"first_name"`
	LastName      string       `json:"last_name"`
	Role          UserRole     `json:"role"`
	UserCreatedAt sql.NullTime `json:"user_created_at"`
	UserUpdatedAt sql.NullTime `json:"user_updated_at"`
}

func (q *Queries) GetEnrollmentsWithDetailsBySection(ctx context.Context, sectionID uuid.UUID) ([]GetEnrollmentsWithDetailsBySectionRow, error) {
	rows, err := q.query(ctx, q.getEnrollmentsWithDetailsBySectionStmt, getEnrollmentsWithDetailsBySection, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEnrollmentsWithDetailsBySectionRow{}
	for rows.Next() {
		var i GetEnrollmentsWithDetailsBySectionRow
		if err := rows.Scan(
			&i.ID,
			&i.SectionID,
			&i.StudentID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentID_2,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isStudentEnrolled = `-- name: IsStudentEnrolled :one
SELECT EXISTS(
    SELECT 1 FROM section_enrollments
    WHERE section_id = $1 AND student_id = $2
)
`

type IsStudentEnrolledParams struct {
	SectionID uuid.UUID `json:"section_id"`
	StudentID uuid.UUID `json:"student_id"`
}

func (q *Queries) IsStudentEnrolled(ctx context.Context, arg IsStudentEnrolledParams) (bool, error) {
	row := q.queryRow(ctx, q.isStudentEnrolledStmt, isStudentEnrolled, arg.SectionID, arg.StudentID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const unenrollStudent = `-- name: UnenrollStudent :exec
DELETE FROM section_enrollments
WHERE section_id = $1 AND student_id = $2
`

type UnenrollStudentParams struct {
	SectionID uuid.UUID `json:"section_id"`
	StudentID uuid.UUID `json:"student_id"`
}

func (q *Queries) UnenrollStudent(ctx context.Context, arg UnenrollStudentParams) error {
	_, err := q.exec(ctx, q.unenrollStudentStmt, unenrollStudent, arg.SectionID, arg.StudentID)
	return err
}

const updateCourseSection = `-- name: UpdateCourseSection :one
UPDATE course_sections
SET
    name = COALESCE($2, name),
    teacher_id = COALESCE($3, teacher_id),
    max_students = COALESCE($4, max_students),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, course_id, teacher_id, max_students, created_at, updated_at, name
`

type UpdateCourseSectionParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	TeacherID   uuid.UUID `json:"teacher_id"`
	MaxStudents int32     `json:"max_students"`
}

func (q *Queries) UpdateCourseSection(ctx context.Context, arg UpdateCourseSectionParams) (CourseSection, error) {
	row := q.queryRow(ctx, q.updateCourseSectionStmt, updateCourseSection,
		arg.ID,
		arg.Name,
		arg.TeacherID,
		arg.MaxStudents,
	)
	var i CourseSection
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.TeacherID,
		&i.MaxStudents,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}
